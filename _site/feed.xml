<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-19T12:58:36-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nicholas Bartlett</title><subtitle>On this site you can expect to find detailed posts that aim to teach as well as any random thoughts I think worthy of sharing -- hopefully both are useful and interesting!
</subtitle><author><name>Nicholas Bartlett</name></author><entry><title type="html">Sports-Betting Arbitrage: Complex Arbitrage Through Linear/Quadratic Programming</title><link href="http://localhost:4000/sports-arb-linprog" rel="alternate" type="text/html" title="Sports-Betting Arbitrage: Complex Arbitrage Through Linear/Quadratic Programming" /><published>2023-02-04T00:00:00-06:00</published><updated>2023-02-04T00:00:00-06:00</updated><id>http://localhost:4000/sports-arb-complex-linprog</id><content type="html" xml:base="http://localhost:4000/sports-arb-linprog"><![CDATA[<p>Basic arbitrage is remarkably difficult to find in sports markets these days. More complex arbitrage strategies, however, are more prevalent. This article builds out the idea of using numerical methods (specifically linear programming) to find more complex arbitrage strategies. At the end, we implement this idea in Python and show an example.</p>

<!--more-->

<h3 id="the-setup">The Setup</h3>

<p>The foundation of what we refer to as a “complex arbitrage” in this article is that notion certain bets may pay out across multiple outcomes. Different sportsbooks often have different ways that they like to group outcomes, and as a result the bets offered don’t always match up. This prevents us from using the simple formula we found in the article on sports-betting <a href="/sports-arb-simple">arbitrage for simpler cases</a>. In fact, there often is no analytical formula for arbitrage – instead we must use optimization algorithms to find the optimal bets to place. Much of this article will rely on ideas introduced in the first article, so check it out if the ideas below are unclear.</p>

<h4 id="notation">Notation</h4>

<p>Let \(A = \begin{bmatrix} \vec a_1 \\ \vdots \\ \vec a_n \end{bmatrix} \in \mathbb{R}^{n \times b}\) be the matrix containing the payouts for each of the $n$ outcomes and the $b$ available bets that can be placed. For example, let $\text{Book 1}$ offer an under $5$ goals scored bet where an outcome of $5$ goals results in a push (money back). Let $\text{Book 2}$ offer both over and under $5.5$ goals scored bets, and let $\text{Book 3}$ offer a bet that pays only if there is exactly $5$ goals scored. Then our payout matrix might look like</p>

\[A = 
\begin{array}{c c} 
&amp; \begin{array}{c c c} \text{Bet }1 &amp; \text{Bet }2 &amp; \text{Bet }3 &amp; \text{Bet }4 \end{array} \\
\begin{array}{c c c} \text{Under 5 Goals} \\ \text{5 Goals} \\ \text{Over 5 Goals} \end{array} &amp;
\left[
\begin{array}{c c c}
\;\;\; 1.55 \;\;\; &amp; \;\;\; 0 \;\;\; &amp; \;\;\; 1.8 \;\;\; &amp; \;\;\; 0 \;\;\; \\
1 &amp; 0 &amp; 0 &amp; 11 \\
0 &amp; 3 &amp; 0 &amp; 0
\end{array}
\right]
\end{array}. \notag\]

<p>Also, we let $\vec w \in \mathbb{R}^b$ denote the portfolio weighting of each bet. As such, we require that $\vec w$ sums to one, or $\vec 1 ^\intercal \vec w = 1$. In addition, we cannot “short” any bets, meaning $\vec w \geq 0$. Lastly, we will use the notation $A_{-j} \in \mathbb{R}^{(n-1) \times b}$ to denote the matrix $A$ with its $j$-th row removed (the vector $\vec a_j$ is removed).</p>

<p class="info"><strong>Note:</strong> This approach assumes that the $n$ outcomes are mutually exclusive and span the entire set of possible outcomes. We cannot have arbitrage if there are outcomes that we cannot bet on.</p>

<h3 id="the-problem">The Problem</h3>

<p>From here, we can move to solving the problem. Depending on how we set things up, our objective function will differ slightly, however they are all still arbitrages. Below, we walk through a few different ideas of how to set the problems up – and of course, how to solve them.</p>

<h4 id="solving-the-problem">Solving The Problem</h4>

<p>Problems of the forms that are seen below are called linear programs, and luckily their are many optimization algorithms available to solve linear programming problems. In our implementation, we will use SciPy’s optimization package in Python which has a built in linear programming solver. In doing so, we will have to group all of our inequality constraints together into one big matrix, and likewise with our equality constraints. Part of the art of solving optimization problems is framing them in such a way that we can actually solve them.</p>

<p class="info"><strong>Note:</strong> Sometimes, <em>there is no solution</em>. This happens when our constraints are so restrictive that no $\vec w$ is capable of satisfying them all. This means that no arbitrage is possible. Although unlikely, it is also possible that there are multiple solutions, where multiple betting strategies have the exact same result.</p>

<h4 id="maximizing-a-specific-outcome-textproblem-1">Maximizing A Specific Outcome ($\text{Problem #1}$)</h4>

<p>To have arbitrage, we must have no outcomes that would result in a loss, and at least one or more outcome(s) that would result in a positive profit. There are numerous ways that we could express our desire for profit mathematically, and we will explore a few of these. For now, let’s assume that we simply want to maximize our profit in outcome $j$. Our objective is thus as follows:</p>

\[\begin{align}
\text{Maximize: }&amp; \vec a_j ^ \intercal \vec w \\
\text{such that:}&amp; \notag \\
&amp; \vec 1 ^\intercal \vec w = 1 \notag \\
&amp; \vec w \geq 0 \notag \\
&amp; A \vec w \geq 1 \notag
\end{align}\]

<h4 id="making-equal-payouts-textproblem-2">Making Equal-Payouts ($\text{Problem #2}$)</h4>

<p>Ideally, we can recieve a profit in <em>every</em> outcome. Fortunately, we can use linear programming to solve for these arbitrages as well. The caveat is that these opportunities are much more rare. Now, our objective becomes</p>

\[\begin{align*}
\text{Maximize: }&amp; \vec a_j ^ \intercal \vec w \\
\text{such that:}&amp; \\
&amp; \vec 1 ^\intercal \vec w = 1 \\
&amp; \vec a_1 ^ \intercal \vec w = \vec a_2 ^ \intercal \vec w = \dots = \vec a_n ^ \intercal \vec w \\
&amp; \vec w \geq 0
\end{align*}\]

<p>where now our choice of $j$ is trivial. In order to use linear programming, we need to put things in a different form. Note that the last constraint is equivalent to $\vec a_i ^ \intercal \vec w = \vec a_j ^ \intercal \vec w$ for $i=1,2, \dots, n$. Dropping the redundant $j$-th row, and letting \(J = \begin{bmatrix} \vec a_j \\ \vdots \\ \vec a_j \end{bmatrix} \in \mathbb{R}^{(n-1) \times b}\), then this constraint is written as</p>

\[A_{-j} \vec w = J \vec w \\
\implies (A_{-j}-J) \vec w = 0.
\notag\]

<p>With this, our objective is</p>

\[\begin{align}
\text{Maximize: }&amp; \vec a_j ^ \intercal \vec w \\
\text{such that:}&amp; \notag \\
&amp; \vec 1 ^\intercal \vec w = 1 \notag \\
&amp; (A_{-j}-J) \vec w = 0 \notag \\
&amp; \vec w \geq 0 \notag \\
\end{align}\]

<p>and we can proceed with our linear programming algorithms.</p>

<p class="info"><strong>Note:</strong> The formulation above could technically have a solution leading to a guaranteed loss. Although we could choose to prevent this, sometimes it can be useful to see a loss. Creating the <em>best</em> possible even-payout arbitrage (which could be negative) provides a way to assess how large the pricing discrepancies are between books/bets, which is closely related to how fair the pricing is in general.</p>

<h4 id="maximizing-expected-profit-textproblem-3">Maximizing Expected Profit ($\text{Problem #3}$)</h4>

<p>To add some flavor to the discussion, and to illustrate the breadth of possibilities available, we will demonstrate how to use linear programming to maximize the expected profit earned while still ensuring no losses. Note that in order to utilize this method, one must have a prior distribution for the outcomes, meaning we must assign a probability to each outcome. Realistically, this approach would best serve situations in which arbitrage is available and one has a strong belief about the likelihood of each event. In such situations, this method will maximize your expected profit.</p>

<p>Let $\vec d \in \mathbb{R}^n$ be our prespecified probability distribution so that $d_i$ holds the probability of outcome $i$ occurring. Knowing that</p>

\[E[\text{Payout}]=\vec d ^\intercal (A \vec w) = (\vec d ^\intercal A) \vec w, \notag\]

<p>we can easily write our objective as</p>

\[\begin{align}
\text{Maximize: }&amp; (\vec d ^\intercal A) \vec w \\
\text{such that:}&amp; \notag \\
&amp; \vec 1 ^\intercal \vec w = 1 \notag \\
&amp; \vec w \geq 0 \notag \\
&amp; A \vec w \geq 1. \notag
\end{align}\]

<p>The output of a formulation such as this is somewhat useful, however thinking about probability distributions and $E[\text{profit}]$ becomes far more interesting when we discuss the use of quadratic programming to minimize variance. More on this below.</p>

<h3 id="the-existence-of-a-solution">The Existence Of A Solution</h3>

<p>Taking a step back and shifting to a geometric perspective leads to an obvious but interesting conclusion: the existence of a solution depends entirely on the constraints. Specifically, the constraints specify a $b$-dimensional region (called the feasible region) in which $\vec w$ could live and still satisfy each constraint. If such a region doesn’t exist, then clearly the problem has no solution.</p>

<p>The point is that $\text{Problem #1}$ and $\text{Problem #3}$ have the same constraints, and thus if one of them has a solution then both of them have a solution. The difference between them is which direction we need to move $\vec w$ within the feasible region to maximize the given objective. As such, once we establish our constraints there is freedom to choose an objective that suits our needs. Of course there is always the possibility that the feasible region is a point, which would lead all objectives to have the same solution.</p>

<h4 id="equal-payout-arbitrage-is-rare">Equal-Payout Arbitrage Is Rare</h4>

<p>Generally speaking (i.e. given no specific form for $A$) we see that $\text{Problem #2}$ has additional equality constraints such that in practice it is far less likely to find (profitable) arbitrage in this situation. As a result, it is beneficial to look for this type of arbitrage only after finding arbitrages of the other form(s).</p>

<p>These additional equality constraints specify a region of its own, which we will call $\text{Region X}$. Referring to the region generated by either $\text{Problem #1}$ or $3$ as $\text{Region Y}$, then $\text{Problem #2}$ will only have a profitable arbitrage opportunity if some part of $\text{Region X}$ overlaps with $\text{Region Y}$, or $\text{Region X} \cap \text{Region Y} \neq \emptyset$.</p>

<p>It goes without saying that certainty in payouts is desirable, which is why an equal-payout arbitrage is worth seeking. But clearly there is only arbitrage inside $\text{Region Y}$, so perhaps there is a better way to go about our goal of minimizing variance? In fact, there is: quadratic programming.</p>

<h3 id="quadratic-programming">Quadratic Programming</h3>

<p>With quadratic programming, we can start in $\text{Region Y}$ and minimize variance from there. If there is a profitable equal-payout arbitrage then we will find it. If there is not, then we will find the next best thing. Quadratic programming, in the form we will discuss, is quite similar to linear programming but instead of having a linear objective function we have a quadratic objective function.</p>

<p>Specifically, we seek to minimize variance. Let $\Sigma \in \mathbb{R}^{b \times b}$ denote the covariance matrix of our bet payouts under the distribution $\vec d$ discussed in $\text{Problem #3}$. Knowing that the total portfolio variance is given by $\vec w ^\intercal \Sigma \vec w$, then our objective is</p>

\[\begin{align}
\text{Minimize: }&amp; \vec w ^\intercal \Sigma \vec w \\
\text{such that:}&amp; \notag \\
&amp; \vec 1 ^\intercal \vec w = 1 \notag \\
&amp; \vec w \geq 0 \notag \\
&amp; A \vec w \geq 1 \notag \\
&amp; (\vec d ^\intercal A) \vec w \geq r^*, \notag
\end{align}\]

<p>where \(r^*\) is some arbitrary expected return threshold. The idea is that <em>given</em> some defined level of return, we want to find the $\vec w$ that <em>minimizes</em> the portfolio variance. If we did not include the $r^*$ constraint then we would always just find the global minimum variance portfolio. By including it, we allow ourselves the opportunity to choose exactly what we are looking for.</p>

<p class="info"><strong>Note:</strong> In fact, there may be multiple minimum variance portfolios. Given our general form for $A$, we can ensure that $\Sigma$ is positive semi-definite (just like any covariance matrix) but not necessarily positive definite. This is because we might have some bet(s) that is a linear combination of other bets. If $\Sigma$ is positive semi-definite but not positive definite, then we will have multiple solutions to $(4)$. Thus, by including $r^*$ we can seek the best possible portfolio.</p>

<p>Realistically, we would set a range of values for \(r^*\) and compare the expected return with the variance for each. As such, it is useful to have some bounds on the values to compute. First, we know that an arbitrage defined by $\text{Region Y}$ is always profitable. Second, we know that the maximum expected return we could possibly earn with arbitrage would be given by the output of $\text{Problem #3}$. If we call the optimum for $\text{Problem #3}$ $r_\text{max}$, then we know that $0 \leq r^* \leq r_\text{max}$.
Any algorithm computing across this range could start at $r^*=0$ and then immediately jump to whatever expected return was found in that first step, and then carry on from there until $r_\text{max}$.</p>

<h4 id="the-prior-distribution">The Prior Distribution</h4>

<p>An evident downfall of this approach is the extreme difficulty in properly establishing a probability distribution for the outcomes. If you were able to predict the probabilities with any decent accuracy you would already be an extremely profitable sports-bettor. Still, this approach is quite beneficial even under basic assumptions. One option would be to assume a completely uniform distribution – in which case we simply want to seek even payouts. Another option could be to use the implied probabilities present in the odds, take some sort of average by outcome, and then scale everything so that $\vec d$ sums to one.</p>

<h3 id="python-implementation">Python Implementation</h3>
<p>Below, we provide some basic code for both the linear programming and quadratic programming problems. We use <code class="language-plaintext highlighter-rouge">scipy</code> for the the former and <code class="language-plaintext highlighter-rouge">cvxopt</code> for the latter.</p>

<h4 id="linear-programming-textproblem-2">Linear Programming ($\text{Problem #2}$)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>

<span class="k">def</span> <span class="nf">complex_arb_equal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">notional</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_outcomes</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="s">'''
    Given matrix A of payouts, calculates an arbitrage the maximizes the profit in the event of outcome j.
    Note that j is indexed starting from 0.
    '''</span>
    
    <span class="c1"># Dimensions (n: number of outcomes, b: number of available bets)
</span>    <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
    
    <span class="c1"># Objective (WLOG we can always let this be the first outcome, but we'll leave j in for clarity purposes)
</span>    <span class="n">obj</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1">### BUILDING THE CONSTRAINTS ###
</span>    
    <span class="c1"># Equality constraint: weights sum to 1
</span>    <span class="n">matrix_eq_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">constr_eq_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Equality constraint: (A_-j - J) w = 0
</span>    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">A_minus_j</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">j</span><span class="p">]</span>
    
    <span class="n">matrix_eq_2</span> <span class="o">=</span> <span class="n">A_minus_j</span> <span class="o">-</span> <span class="n">J</span>
    <span class="n">constr_eq_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Combining equality constraints
</span>    <span class="n">matrix_eq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">matrix_eq_1</span><span class="p">,</span> <span class="n">matrix_eq_2</span><span class="p">])</span>
    <span class="n">constr_eq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr_eq_1</span><span class="p">,</span> <span class="n">constr_eq_2</span><span class="p">)</span>

    <span class="c1"># Inequality constraints: no potential losses
</span>    <span class="n">matrix_ineq</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span>
    <span class="n">constr_ineq</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Calculate the weights. By default the bounds are (0, None) but we add it anyway to emphasize that the w &gt;= 0
</span>    <span class="n">prog</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">obj</span><span class="p">,</span> <span class="n">A_eq</span> <span class="o">=</span> <span class="n">matrix_eq</span><span class="p">,</span> <span class="n">b_eq</span> <span class="o">=</span> <span class="n">constr_eq</span><span class="p">,</span> <span class="n">A_ub</span> <span class="o">=</span> <span class="n">matrix_ineq</span><span class="p">,</span> <span class="n">b_ub</span> <span class="o">=</span> <span class="n">constr_ineq</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
    
    <span class="c1"># Check the status. Typically we will only encounter status 0 (success) or 2 (problem is unfeasible/no solution)
</span>    <span class="c1"># For now, if we get another status we will just alert the user.
</span>    <span class="k">if</span> <span class="n">prog</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'No solution was found. Arbitrage is not feasible.'</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">elif</span> <span class="n">prog</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status </span><span class="si">{</span><span class="n">prog</span><span class="p">.</span><span class="n">status</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">prog</span><span class="p">.</span><span class="n">message</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        
    <span class="c1"># If arb was found, extract the bet weights, and the returns in each situation
</span>    <span class="n">w_vec</span> <span class="o">=</span> <span class="n">prog</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">returns</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">prog</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="c1">#.round(4)
</span>    
    <span class="k">if</span> <span class="n">return_outcomes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">notional</span> <span class="o">*</span> <span class="n">w_vec</span><span class="p">,</span> <span class="n">returns</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">notional</span> <span class="o">*</span> <span class="n">w_vec</span>
</code></pre></div></div>

<h4 id="quadratic-programming-1">Quadratic Programming</h4>
<p>First, we construct a basic function to calculate the covariance matrix, $\Sigma$, given $A$. Then we implement the quadratic program.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">cvxopt</span>
<span class="kn">from</span> <span class="nn">cvxopt.solvers</span> <span class="kn">import</span> <span class="n">qp</span>
<span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="n">cvxopt</span><span class="p">.</span><span class="n">solvers</span><span class="p">.</span><span class="n">options</span><span class="p">[</span><span class="s">"show_progress"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">cvxopt</span><span class="p">.</span><span class="n">solvers</span><span class="p">.</span><span class="n">options</span><span class="p">[</span><span class="s">"abstol"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-10</span>

<span class="c1"># Covariance Matrix
</span><span class="k">def</span> <span class="nf">calculate_sigma</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">):</span>
    
    <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
        
    <span class="n">mu_vec</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">d_vec</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">outer</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu_vec</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sigma</span>

<span class="c1"># Quadratic Programming
</span><span class="k">def</span> <span class="nf">complex_arb_minvar</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">r_star</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">d_vec</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">notional</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">return_outcomes</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="c1"># Dimensions (n: number of outcomes, b: number of available bets)
</span>    <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
    
    <span class="c1"># Uniform by default
</span>    <span class="k">if</span> <span class="n">d_vec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">d_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    
    <span class="c1"># Covariance matrix
</span>    <span class="n">sigma</span> <span class="o">=</span> <span class="n">calculate_sigma</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">)</span>
    
    <span class="c1"># Reshape to please CVXOPT
</span>    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Objective Function. CVXOPT requires an input for the second AND first degree, but the first degree is 0 for this.
</span>    <span class="n">P</span> <span class="o">=</span> <span class="n">sigma</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    
    <span class="c1">### BUILDING THE CONSTRAINTS ###
</span>    
    <span class="c1"># Equality constraint: weights sum to 1
</span>    <span class="n">matrix_eq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">constr_eq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Inequality constraints: no potential losses
</span>    <span class="n">matrix_ineq_1</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span>
    <span class="n">constr_ineq_1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="c1"># Inequality constraints: minimum expected return
</span>    <span class="n">matrix_ineq_2</span> <span class="o">=</span> <span class="o">-</span><span class="n">d_vec</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span>
    <span class="n">constr_ineq_2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">r_star</span><span class="p">)</span>
    
    <span class="c1"># Inequality constraints: all weights are positive
</span>    <span class="n">matrix_ineq_3</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">constr_ineq_3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    
    <span class="c1"># Combine them
</span>    <span class="n">matrix_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">matrix_ineq_1</span><span class="p">,</span> <span class="n">matrix_ineq_2</span><span class="p">,</span> <span class="n">matrix_ineq_3</span><span class="p">])</span>
    <span class="n">constr_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr_ineq_1</span><span class="p">,</span> <span class="n">constr_ineq_2</span><span class="p">),</span> <span class="n">constr_ineq_3</span><span class="p">])</span>
    
    <span class="c1"># Convert to CVXOPT's matrix class of type double
</span>    <span class="n">P</span><span class="p">,</span> <span class="n">matrix_eq</span><span class="p">,</span> <span class="n">matrix_ineq</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">),</span> <span class="n">matrix</span><span class="p">(</span><span class="n">matrix_eq</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">),</span> <span class="n">matrix</span><span class="p">(</span><span class="n">matrix_ineq</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">)</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">constr_eq</span><span class="p">,</span> <span class="n">constr_ineq</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">),</span> <span class="n">matrix</span><span class="p">(</span><span class="n">constr_eq</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">),</span> <span class="n">matrix</span><span class="p">(</span><span class="n">constr_ineq</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">)</span>
    
    <span class="c1"># Calculate the weights. By default the bounds are (0, None) but we add it anyway to emphasize that the w &gt;= 0
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">qp</span><span class="p">(</span><span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">matrix_ineq</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">constr_ineq</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">matrix_eq</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">constr_eq</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Problem not feasible! CVXOPT domain error."</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="c1"># Check the status
</span>    
    <span class="k">if</span> <span class="n">prog</span><span class="p">[</span><span class="s">'status'</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'optimal'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'No solution was found. Arbitrage is not feasible.'</span><span class="p">)</span>
        <span class="k">return</span>
        
    <span class="c1"># If arb was found, extract the bet weights, and the returns in each situation
</span>    <span class="n">w_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">prog</span><span class="p">[</span><span class="s">'x'</span><span class="p">])</span>
    <span class="n">returns</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">w_vec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">w_vec</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">sigma</span> <span class="o">@</span> <span class="n">w_vec</span><span class="p">).</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_outcomes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">notional</span> <span class="o">*</span> <span class="n">w_vec</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">std_dev</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">returns</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">notional</span> <span class="o">*</span> <span class="n">w_vec</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">std_dev</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Nicholas Bartlett</name></author><category term="Python" /><category term="Sports-Betting" /><category term="Optimization" /><category term="Numerical-Methods" /><summary type="html"><![CDATA[Basic arbitrage is remarkably difficult to find in sports markets these days. More complex arbitrage strategies, however, are more prevalent. This article builds out the idea of using numerical methods (specifically linear programming) to find more complex arbitrage strategies. At the end, we implement this idea in Python and show an example.]]></summary></entry><entry><title type="html">Sports-Betting Arbitrage: The Simple Case</title><link href="http://localhost:4000/sports-arb-simple" rel="alternate" type="text/html" title="Sports-Betting Arbitrage: The Simple Case" /><published>2023-01-27T00:00:00-06:00</published><updated>2023-01-27T00:00:00-06:00</updated><id>http://localhost:4000/sports-arb-simple</id><content type="html" xml:base="http://localhost:4000/sports-arb-simple"><![CDATA[<p>Sports betting has become commonplace as of late. What is not commonplace, however, is an understanding of how sports betting works at a fundamental level. This article seeks to illuminate the idea of arbitrage in sports markets, and along the way discuss concepts that are useful even to the casual sports-bettor. After discussing the mathematics behind it all, we implement our ideas in Python so that we can easily find and assess arbitrage opportunities.</p>

<!--more-->

<h3 id="overview">Overview</h3>

<h4 id="what-are-we-looking-to-solve">What are we looking to solve?</h4>

<p>We are looking to find and implement a formula that we can use to answer three questions:<br />
  <strong>1)</strong> How do I know whether a profitable arbitrage is available?<br />
  <strong>2)</strong> What bets to place in order to take advantage of it?<br />
  <strong>3)</strong> How profitable will it be?</p>

<p>To begin, let’s assume that we have gathered the best odds available for any given outcome – ideally across many books – and we organize them into a table such as the following:</p>

\[\begin{array}{c c} 
&amp; \begin{array}{c c c} \text{Bet }1 &amp; \text{Bet }2 &amp; \text{Bet }3 \\ \end{array} \\
\begin{array}{c c c} \text{Team 1 wins} \\ \text{Tie} \\ \text{Team 2 wins} \end{array} &amp;
\left[
\begin{array}{c c c}
-120 &amp;  &amp;  \\
 &amp; +190 &amp;  \\
 &amp;  &amp; +430
\end{array}
\right]
\end{array} \notag\]

<p>Clearly, there is only one “best odds” for each outcome, so we can always arrange our data into a format such as the table above. From here, we wish to determine whether there is some combination of bets that will guarantee us a positive profit.</p>

<p class="info"><strong>Note:</strong> It must be said that we assume that the available bets cover all possible outcomes. We cannot construct an arbitrage if there are outcomes that we cannot bet on.</p>

<h4 id="converting-odds-to-payouts">Converting Odds to Payouts</h4>

<p>The first step is to convert the above odds into a more interpretable and mathematically-friendly form: payouts.</p>

<p>A bet’s payout is simply the amount of money you will have if you bet <span>$</span>1 and you win. The formula is given by:</p>

\[\text{Payout(Odds)}= \begin{cases}
                    \frac{|\text{Odds}| + 100}{|\text{Odds}|}, &amp; \text{Odds are -} \\
                    \frac{|\text{Odds}| + 100}{100}, &amp; \text{Odds are +}
                     \end{cases}.
                     \notag\]

<p>Thus, for example, if a bet is $-200$ then payout is $1.5$ which corresponds to a $50\%$ return if the bet is a success. With this, we can more easily use math to help us find the optimal formula.</p>

<h3 id="the-arbitrage-formula">The Arbitrage Formula</h3>

<p>In this section, we will derive a general formula for an arbitrage portfolio that pays equally across all outcomes using basic linear algebra. The math helps us derive the answer in this section, but in the next section we will connect it more intuitively to financial concepts.</p>

<h4 id="notation">Notation</h4>

<p>Let $A \in \mathbb{R}^{n \times n}$ be the matrix containing the payouts for each of the $n$ outcomes. Just like above, the columns of $A$ represent the books, and the rows represent each outcome. Similarly, we restrict ourselves to the case where a single bet corresponds to a single outcome – meaning that we can’t have a bet that wins in multiple outcomes – and we only ever want to look at the most favorable odds available for each outcome. Thus we know that $A$ will be square (there is only 1 best payout per outcome), and furthermore $A$ takes the form</p>

\[\begin{align*}

A = \text{diag}(\vec a),

\end{align*}\]

<p>where $\vec a \in \mathbb{R}^n$, and $a_i&gt;1$ are the payouts of the $i$th outcome. The $0$’s in the non-diagonal entries of $A$ represent the fact that if the given bet doesn’t succeed then it pays out $0$. We let $\vec{w} \in \mathbb{R}^n$ denote the weighting of our “portfolio” of bets, and we require that this sums to one.</p>

<h4 id="deriving-the-formula">Deriving The Formula</h4>

<p>In order to construct an arbitrage that has equal payouts over every outcome, we simply want to find $\vec w$ and some constant scalar $k$ such that the following is satisfied:</p>

\[\begin{align}

A\vec w = \vec 1 k,\\
\vec 1^\intercal \vec w = 1,

\end{align}\]

<p>Clearly, because a ${$1}$ portfolio will turn into ${$k}$ in every outcome, then if $k&gt;1$ then we have a profitable arbitrage. Because $A$ is always invertible, we solve $(1)$ as</p>

\[\vec w = k A^{-1}\vec 1 \notag\]

<p>and we can plug this into $(2)$ to find</p>

\[k = (\vec 1^\intercal A^{-1} \vec 1)^{-1}.\]

<p>To finish, we then have that</p>

\[\vec w = \frac{A^{-1}\vec 1}{\vec 1^\intercal A^{-1} \vec 1}\]

<p>gives us our arbitrage betting formula.</p>

<h3 id="a-more-intuitive-look">A More Intuitive Look</h3>

<h4 id="implied-risk-neutral-probability">Implied (Risk-Neutral) Probability</h4>

<p>It isn’t necessarily easy to garner intuition of the formula for $\vec w$ at first glance, but by shifting our perspective we can shed some light. First, we must discuss implied (more formally referred to as “risk-neutral”) probabilities. Put simply, it is the probability that the betting market has baked into the current odds (or that your sportsbook has set). If an outcome has probability $p$ of occurring, and it pays out $a$, then by placing a ${$1}$ bet on that outcome we have an expected profit of</p>

\[E[\text{Profit}] = p \cdot (a-1) + (1-p) \cdot (-1) \notag\]

<p>If this is positive, then people will keep betting on this side until that is no longer the case. If its negative, people will bet on the other side until that is no longer the case. We find balance only when $E[\text{Profit}]=0$, and thus if the current odds/payout are given by $a$ then the market (on aggregate) views the probability of the outcome to be the value of $p$ such that</p>

\[E[\text{Profit}] = p \cdot (a-1) + (1-p) \cdot (-1)=0 \notag \\
\implies p=\frac 1a.\]

<h4 id="the-simplified-formula">The Simplified Formula</h4>

<p>Using this idea, we can re-write our derivation above in terms of implied probabilities – replace the $a$’s with $\frac 1p$’s. Then because $A$ is diagonal we have $A=P^{-1}$ where $P \in \mathbb{R}^n$ is a diagonal matrix representing the risk-neutral probabilities (prices) of each bet. With this,</p>

\[\vec w = \frac{P\vec 1}{\vec 1^\intercal P \vec 1},\]

<p>and if we let $\vec p$ denote the diagonal of $P$ just as we let $\vec a$ denote the diagonal of $A$, we can simplify further to get</p>

\[\vec w = \frac{\vec p}{\text{sum}(\vec p)}.\]

<p>In other words, the proper weightings are the implied probabilities scaled so that the weights sum to one! Furthermore, our profit is $k=\frac{1}{\text{sum}(\vec p)}$, meaning that we have a profitable arbitrage if the sum of the implied probabilities is less than one.</p>

<h4 id="why-is-this-so">Why Is This So?</h4>

<p>As an example, consider a situation where there are only two bets: $\text{outcome 1}$ has an implied probability of $55\%$ and $\text{outcome 2}$ has an implied probability of $52\%$. There are only two outcomes but their probabilities add up to more than $100\%$! This may be the case because the sportsbooks need to make money and they do so by offering slightly unfavorable bets on all sides. By doing so, the odds are so unfavorable that no profitable arbitrage is possible. You can, however, lock in a sure loss by using the formula for $\vec w$.</p>

<p>If we consider an asset that pays ${$1}$ if the outcome happens and ${$0}$ if it does not, then it is not difficult to see that the implied probability <em>is</em> the market price. So if I pay $55$ cents and $52$ cents for the assets corresponding to $\text{outcomes 1}$ and $2$ respectively, then no matter what happens I paid ${$1.07}$ and won ${$1}$ – a sure loss.</p>

<p>Now consider if $\text{outcome 1}$ has an implied probability of $55\%$ and $\text{outcome 2}$ has an implied probability of $43\%$. Now, I can pay $55$ cents and $43$ cents respectively, meaning I paid $98$ cents and I always get ${$1}$ – a sure profit. That is why we need $\text{sum}(\vec p)&lt;1$ for a profitable arbitrage.</p>

<p class="warning"><strong>Warning:</strong> For the active sports bettors out there, this is why its typically not a great idea to make many conflicting bets at the same time – 99.99% of the time the odds offered by the sportsbook leave absolutely no room for a profitable arbitrage-like situation. Instead, you’re far more likely to lock yourself into a losing situation. It is incredibly easy to make a few bets on the same game that contradict each other in subtle ways, and by doing so you are simply decreasing the variance of your outcome. Given how unfavorable the odds usually are, particularly if you make these bets all on the same sportsbook, you are almost certain to lose money.</p>

<h4 id="calculating-the-implied-probability-from-the-odds">Calculating the Implied Probability From the Odds</h4>

<p>Although this formula follows directly from the discussion above, it is useful to highlight exactly how we can calculate the implied probabilities from the odds. Although some sportsbooks offer this in their app, for those that don’t it is incredibly powerful to understand the odds from a probability perspective. The formula is:</p>

\[\text{Implied Probability(Odds)}= \begin{cases}
                    \frac{|\text{Odds}|}{|\text{Odds}|+100}, &amp; \text{Odds are -} \\
                    \frac{100}{|\text{Odds}| + 100}, &amp; \text{Odds are +}
                     \end{cases}.
                     \notag\]

<p class="info"><strong>Note:</strong> If you sportsbet frequently, you should memorize this formula.</p>

<h3 id="python-implementation">Python Implementation</h3>

<p>In this section, we will briefly walk through Python code that can be used to quickly and easily calculate the arbitrage bets, if any exist. First, we will implement some functions to calculate what we discussed above, and then we will create a function that combines everything into one. We will demonstrate with a brief example.</p>

<h4 id="the-basic-functions">The Basic Functions</h4>

<p>After we <code class="language-plaintext highlighter-rouge">import numpy as np</code>, our first step is to implement a function that converts sportsbook odds to implied probabilities as previously discussed. This is done as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">odd_to_price</span><span class="p">(</span><span class="n">odd</span><span class="p">):</span>
    <span class="s">'''
    Converts a sportsbook's odds to implied probability/price.
    '''</span>
    
    <span class="k">if</span> <span class="n">odd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">100</span> <span class="o">/</span> <span class="p">(</span><span class="mi">100</span> <span class="o">+</span> <span class="n">odd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">odd</span> <span class="o">/</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">odd</span><span class="p">)</span>

    
<span class="k">def</span> <span class="nf">odds_to_prices</span><span class="p">(</span><span class="n">odds</span><span class="p">):</span>
    <span class="s">'''
    Converts a matrix of sportsbook odds to implied probabilities/prices.
    '''</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">odd_to_price</span><span class="p">)(</span><span class="n">odds</span><span class="p">)</span>
</code></pre></div></div>

<p>Second, we want to implement our calculations for the arbitrage weights in the form of equation $(6)$. The <code class="language-plaintext highlighter-rouge">notional</code> parameter refers to the total amount of money you want to bet. Also, if there is no profitable arb available, the function returns nothing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_simple_arb</span><span class="p">(</span><span class="n">p_vec</span><span class="p">,</span> <span class="n">notional</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="s">'''
    Given the p-vector holding the implied probalities for each outcome, calculate the arbitrage.
    '''</span>
    
    <span class="c1"># Calculate our constant k
</span>    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">p_vec</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
    
    <span class="c1"># No need to calculate the weightings if the arb wouldn't be profitable
</span>    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"No profitable arb available, return is: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s">%"</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="c1"># Print the profitability
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Arb return: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s">%"</span><span class="p">)</span>
    
    <span class="c1"># Calculate our weights
</span>    <span class="n">w_vec</span> <span class="o">=</span> <span class="n">p_vec</span> <span class="o">*</span> <span class="n">k</span>
    
    <span class="c1"># Convert this to a $ amount bet placed
</span>    <span class="n">bets</span> <span class="o">=</span> <span class="n">w_vec</span> <span class="o">*</span> <span class="n">notional</span>
    
    <span class="k">return</span> <span class="n">bets</span>
</code></pre></div></div>

<p>Now, given our odds, we can calculate $\vec p$ and then $\vec w$!</p>

<h4 id="putting-it-all-together-in-a-more-useful-way">Putting it all together in a more useful way</h4>

<p>We can put the above functions together in such a way that makes discovering arbitrage much easier. Consider if we have some bet with $n$ outcomes and we have $b$ different sportsbooks. We can then gather all of the odds data and arrange it into a $n \times b$ matrix such as:</p>

\[\begin{array}{c c} 
&amp; \begin{array}{c c c} \text{Book }1 &amp; \text{Book }2 &amp; \text{Book }3 &amp; \text{Book }4\\ \end{array} \\
\begin{array}{c c c} \text{Team 1 wins} \\ \text{Tie} \\ \text{Team 2 wins} \end{array} &amp;
\left[
\begin{array}{c c c}
\; -120 \; &amp; \; -105 \; &amp; \; -125 \; &amp; \; +110 \; \\
+190 &amp; +175 &amp; +230 &amp; +140 \\
+430 &amp; +515 &amp; +300 &amp; +850
\end{array}
\right]
\end{array} \notag\]

<p>From here, we can automatically:<br />
  <strong>1)</strong> Find the best prices for each outcome.<br />
  <strong>2)</strong> Automate the arbitrage calculations.<br />
  <strong>3)</strong> Return a matrix of the same size that tells us exactly where to bet, and how much.</p>

<p>The code is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_best_prices</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="s">'''
    Finds the best odds from each book, returns it as an array, and also returns the book indices.
    '''</span>
    
    <span class="k">return</span> <span class="n">prices</span><span class="p">.</span><span class="nb">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">prices</span><span class="p">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">simple_arb_from_all_odds</span><span class="p">(</span><span class="n">odds</span><span class="p">,</span> <span class="n">notional</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="s">'''
    Given a rectangular matrix that has all of the odds available for each sportsbook/outcome combination, this function:
    1) finds the best prices/odds for each outcome
    2) calculates the arb weights
    3) returns a corresponding matrix saying exactly how much to bet on each sportsbook/outcome combination 
    '''</span>
    
    <span class="c1"># First convert the odds to prices
</span>    <span class="n">prices</span> <span class="o">=</span> <span class="n">odds_to_prices</span><span class="p">(</span><span class="n">odds</span><span class="p">)</span>
    
    <span class="c1"># Find the best odds for each outcome, and store which book it came from
</span>    <span class="n">p_vec</span><span class="p">,</span> <span class="n">books</span> <span class="o">=</span> <span class="n">find_best_prices</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    
    <span class="c1"># Calculate the arb bets, if any
</span>    <span class="n">bets</span> <span class="o">=</span> <span class="n">calculate_simple_arb</span><span class="p">(</span><span class="n">p_vec</span><span class="p">,</span> <span class="n">notional</span><span class="p">)</span>
    
    <span class="c1"># If no arb, return None
</span>    <span class="k">if</span> <span class="n">bets</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="c1"># The matrix specifying exactly where to bet. We first initialize it to be zeros.
</span>    <span class="n">bet_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">odds</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># Loop through each outcome, mark which sportsbook/bet combo we need to place our bet on, and how much the bet will be.
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bet</span><span class="p">,</span> <span class="n">book</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bets</span><span class="p">,</span> <span class="n">books</span><span class="p">)):</span>
        
        <span class="n">bet_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">book</span><span class="p">]</span> <span class="o">=</span> <span class="n">bet</span>
    
    <span class="k">return</span> <span class="n">bet_matrix</span>
</code></pre></div></div>

<p>Continuing from the example above, if we wanted to bet <span>$</span>100 then the output would be</p>

\[\begin{array}{c c} 
&amp; \begin{array}{c c c} \text{Book }1 &amp; \text{Book }2 &amp; \text{Book }3 &amp; \text{Book }4\\ \end{array} \\
\begin{array}{c c c} \text{Team 1 wins} \\ \text{Tie} \\ \text{Team 2 wins} \end{array} &amp;
\left[
\begin{array}{c c c}
\;\;\; $0 \;\;\; &amp; \;\;\; $0 \;\;\; &amp; \; $0 \; &amp; $53.84 \\
\; $0 \; &amp; \; $0 \; &amp; $34.26 &amp; \; $0 \; \\
\; $0 \; &amp; \; $0 \; &amp; \; $0 \; &amp; $11.90
\end{array}
\right]
\end{array} \notag\]

<p>and the return from this arbitrage would amount to $13.06\%$. Thus, we would bet ${$34.26}$ on $\text{Book 3}$ for a $\text{Tie}$, ${$53.84}$ on $\text{Book 4}$ for $\text{Team 1}$ to win, and ${$11.90}$ on $\text{Book 4}$ for $\text{Team 3}$ to win.</p>

<p class="info"><strong>Note:</strong> Arbitrages of the nature seen in this article are exceedingly rare and typically quite small. For the more complex arbitrage opportunities which are more prevalent, consider reading <a href="/sports-arb-linprog">this article</a> to learn how to capture them.</p>]]></content><author><name>Nicholas Bartlett</name></author><category term="Python" /><category term="Sports-Betting" /><summary type="html"><![CDATA[Sports betting has become commonplace as of late. What is not commonplace, however, is an understanding of how sports betting works at a fundamental level. This article seeks to illuminate the idea of arbitrage in sports markets, and along the way discuss concepts that are useful even to the casual sports-bettor. After discussing the mathematics behind it all, we implement our ideas in Python so that we can easily find and assess arbitrage opportunities.]]></summary></entry></feed>